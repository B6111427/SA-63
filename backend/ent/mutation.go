// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/B6111427/app/ent/booking"
	"github.com/B6111427/app/ent/bookingtype"
	"github.com/B6111427/app/ent/cliententity"
	"github.com/B6111427/app/ent/role"
	"github.com/B6111427/app/ent/user"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBooking      = "Booking"
	TypeBookingtype  = "Bookingtype"
	TypeClientEntity = "ClientEntity"
	TypeRole         = "Role"
	TypeUser         = "User"
)

// BookingMutation represents an operation that mutate the Bookings
// nodes in the graph.
type BookingMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_BOOKING_DATE *time.Time
	_TIME_LEFT    *time.Time
	clearedFields map[string]struct{}
	usedby        *int
	clearedusedby bool
	book          *int
	clearedbook   bool
	using         *int
	clearedusing  bool
	done          bool
	oldValue      func(context.Context) (*Booking, error)
}

var _ ent.Mutation = (*BookingMutation)(nil)

// bookingOption allows to manage the mutation configuration using functional options.
type bookingOption func(*BookingMutation)

// newBookingMutation creates new mutation for $n.Name.
func newBookingMutation(c config, op Op, opts ...bookingOption) *BookingMutation {
	m := &BookingMutation{
		config:        c,
		op:            op,
		typ:           TypeBooking,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBookingID sets the id field of the mutation.
func withBookingID(id int) bookingOption {
	return func(m *BookingMutation) {
		var (
			err   error
			once  sync.Once
			value *Booking
		)
		m.oldValue = func(ctx context.Context) (*Booking, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Booking.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBooking sets the old Booking of the mutation.
func withBooking(node *Booking) bookingOption {
	return func(m *BookingMutation) {
		m.oldValue = func(context.Context) (*Booking, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BookingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BookingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *BookingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetBOOKINGDATE sets the BOOKING_DATE field.
func (m *BookingMutation) SetBOOKINGDATE(t time.Time) {
	m._BOOKING_DATE = &t
}

// BOOKINGDATE returns the BOOKING_DATE value in the mutation.
func (m *BookingMutation) BOOKINGDATE() (r time.Time, exists bool) {
	v := m._BOOKING_DATE
	if v == nil {
		return
	}
	return *v, true
}

// OldBOOKINGDATE returns the old BOOKING_DATE value of the Booking.
// If the Booking object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BookingMutation) OldBOOKINGDATE(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBOOKINGDATE is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBOOKINGDATE requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBOOKINGDATE: %w", err)
	}
	return oldValue.BOOKINGDATE, nil
}

// ResetBOOKINGDATE reset all changes of the "BOOKING_DATE" field.
func (m *BookingMutation) ResetBOOKINGDATE() {
	m._BOOKING_DATE = nil
}

// SetTIMELEFT sets the TIME_LEFT field.
func (m *BookingMutation) SetTIMELEFT(t time.Time) {
	m._TIME_LEFT = &t
}

// TIMELEFT returns the TIME_LEFT value in the mutation.
func (m *BookingMutation) TIMELEFT() (r time.Time, exists bool) {
	v := m._TIME_LEFT
	if v == nil {
		return
	}
	return *v, true
}

// OldTIMELEFT returns the old TIME_LEFT value of the Booking.
// If the Booking object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BookingMutation) OldTIMELEFT(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTIMELEFT is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTIMELEFT requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTIMELEFT: %w", err)
	}
	return oldValue.TIMELEFT, nil
}

// ResetTIMELEFT reset all changes of the "TIME_LEFT" field.
func (m *BookingMutation) ResetTIMELEFT() {
	m._TIME_LEFT = nil
}

// SetUsedbyID sets the usedby edge to User by id.
func (m *BookingMutation) SetUsedbyID(id int) {
	m.usedby = &id
}

// ClearUsedby clears the usedby edge to User.
func (m *BookingMutation) ClearUsedby() {
	m.clearedusedby = true
}

// UsedbyCleared returns if the edge usedby was cleared.
func (m *BookingMutation) UsedbyCleared() bool {
	return m.clearedusedby
}

// UsedbyID returns the usedby id in the mutation.
func (m *BookingMutation) UsedbyID() (id int, exists bool) {
	if m.usedby != nil {
		return *m.usedby, true
	}
	return
}

// UsedbyIDs returns the usedby ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// UsedbyID instead. It exists only for internal usage by the builders.
func (m *BookingMutation) UsedbyIDs() (ids []int) {
	if id := m.usedby; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUsedby reset all changes of the "usedby" edge.
func (m *BookingMutation) ResetUsedby() {
	m.usedby = nil
	m.clearedusedby = false
}

// SetBookID sets the book edge to Bookingtype by id.
func (m *BookingMutation) SetBookID(id int) {
	m.book = &id
}

// ClearBook clears the book edge to Bookingtype.
func (m *BookingMutation) ClearBook() {
	m.clearedbook = true
}

// BookCleared returns if the edge book was cleared.
func (m *BookingMutation) BookCleared() bool {
	return m.clearedbook
}

// BookID returns the book id in the mutation.
func (m *BookingMutation) BookID() (id int, exists bool) {
	if m.book != nil {
		return *m.book, true
	}
	return
}

// BookIDs returns the book ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// BookID instead. It exists only for internal usage by the builders.
func (m *BookingMutation) BookIDs() (ids []int) {
	if id := m.book; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBook reset all changes of the "book" edge.
func (m *BookingMutation) ResetBook() {
	m.book = nil
	m.clearedbook = false
}

// SetUsingID sets the using edge to ClientEntity by id.
func (m *BookingMutation) SetUsingID(id int) {
	m.using = &id
}

// ClearUsing clears the using edge to ClientEntity.
func (m *BookingMutation) ClearUsing() {
	m.clearedusing = true
}

// UsingCleared returns if the edge using was cleared.
func (m *BookingMutation) UsingCleared() bool {
	return m.clearedusing
}

// UsingID returns the using id in the mutation.
func (m *BookingMutation) UsingID() (id int, exists bool) {
	if m.using != nil {
		return *m.using, true
	}
	return
}

// UsingIDs returns the using ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// UsingID instead. It exists only for internal usage by the builders.
func (m *BookingMutation) UsingIDs() (ids []int) {
	if id := m.using; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUsing reset all changes of the "using" edge.
func (m *BookingMutation) ResetUsing() {
	m.using = nil
	m.clearedusing = false
}

// Op returns the operation name.
func (m *BookingMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Booking).
func (m *BookingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *BookingMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._BOOKING_DATE != nil {
		fields = append(fields, booking.FieldBOOKINGDATE)
	}
	if m._TIME_LEFT != nil {
		fields = append(fields, booking.FieldTIMELEFT)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *BookingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case booking.FieldBOOKINGDATE:
		return m.BOOKINGDATE()
	case booking.FieldTIMELEFT:
		return m.TIMELEFT()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *BookingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case booking.FieldBOOKINGDATE:
		return m.OldBOOKINGDATE(ctx)
	case booking.FieldTIMELEFT:
		return m.OldTIMELEFT(ctx)
	}
	return nil, fmt.Errorf("unknown Booking field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BookingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case booking.FieldBOOKINGDATE:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBOOKINGDATE(v)
		return nil
	case booking.FieldTIMELEFT:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTIMELEFT(v)
		return nil
	}
	return fmt.Errorf("unknown Booking field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *BookingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *BookingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BookingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Booking numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *BookingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *BookingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *BookingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Booking nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *BookingMutation) ResetField(name string) error {
	switch name {
	case booking.FieldBOOKINGDATE:
		m.ResetBOOKINGDATE()
		return nil
	case booking.FieldTIMELEFT:
		m.ResetTIMELEFT()
		return nil
	}
	return fmt.Errorf("unknown Booking field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *BookingMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.usedby != nil {
		edges = append(edges, booking.EdgeUsedby)
	}
	if m.book != nil {
		edges = append(edges, booking.EdgeBook)
	}
	if m.using != nil {
		edges = append(edges, booking.EdgeUsing)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *BookingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case booking.EdgeUsedby:
		if id := m.usedby; id != nil {
			return []ent.Value{*id}
		}
	case booking.EdgeBook:
		if id := m.book; id != nil {
			return []ent.Value{*id}
		}
	case booking.EdgeUsing:
		if id := m.using; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *BookingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *BookingMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *BookingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedusedby {
		edges = append(edges, booking.EdgeUsedby)
	}
	if m.clearedbook {
		edges = append(edges, booking.EdgeBook)
	}
	if m.clearedusing {
		edges = append(edges, booking.EdgeUsing)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *BookingMutation) EdgeCleared(name string) bool {
	switch name {
	case booking.EdgeUsedby:
		return m.clearedusedby
	case booking.EdgeBook:
		return m.clearedbook
	case booking.EdgeUsing:
		return m.clearedusing
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *BookingMutation) ClearEdge(name string) error {
	switch name {
	case booking.EdgeUsedby:
		m.ClearUsedby()
		return nil
	case booking.EdgeBook:
		m.ClearBook()
		return nil
	case booking.EdgeUsing:
		m.ClearUsing()
		return nil
	}
	return fmt.Errorf("unknown Booking unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *BookingMutation) ResetEdge(name string) error {
	switch name {
	case booking.EdgeUsedby:
		m.ResetUsedby()
		return nil
	case booking.EdgeBook:
		m.ResetBook()
		return nil
	case booking.EdgeUsing:
		m.ResetUsing()
		return nil
	}
	return fmt.Errorf("unknown Booking edge %s", name)
}

// BookingtypeMutation represents an operation that mutate the Bookingtypes
// nodes in the graph.
type BookingtypeMutation struct {
	config
	op              Op
	typ             string
	id              *int
	_BOOKTYPE_NAME  *string
	clearedFields   map[string]struct{}
	booktype        map[int]struct{}
	removedbooktype map[int]struct{}
	done            bool
	oldValue        func(context.Context) (*Bookingtype, error)
}

var _ ent.Mutation = (*BookingtypeMutation)(nil)

// bookingtypeOption allows to manage the mutation configuration using functional options.
type bookingtypeOption func(*BookingtypeMutation)

// newBookingtypeMutation creates new mutation for $n.Name.
func newBookingtypeMutation(c config, op Op, opts ...bookingtypeOption) *BookingtypeMutation {
	m := &BookingtypeMutation{
		config:        c,
		op:            op,
		typ:           TypeBookingtype,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBookingtypeID sets the id field of the mutation.
func withBookingtypeID(id int) bookingtypeOption {
	return func(m *BookingtypeMutation) {
		var (
			err   error
			once  sync.Once
			value *Bookingtype
		)
		m.oldValue = func(ctx context.Context) (*Bookingtype, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Bookingtype.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBookingtype sets the old Bookingtype of the mutation.
func withBookingtype(node *Bookingtype) bookingtypeOption {
	return func(m *BookingtypeMutation) {
		m.oldValue = func(context.Context) (*Bookingtype, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BookingtypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BookingtypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *BookingtypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetBOOKTYPENAME sets the BOOKTYPE_NAME field.
func (m *BookingtypeMutation) SetBOOKTYPENAME(s string) {
	m._BOOKTYPE_NAME = &s
}

// BOOKTYPENAME returns the BOOKTYPE_NAME value in the mutation.
func (m *BookingtypeMutation) BOOKTYPENAME() (r string, exists bool) {
	v := m._BOOKTYPE_NAME
	if v == nil {
		return
	}
	return *v, true
}

// OldBOOKTYPENAME returns the old BOOKTYPE_NAME value of the Bookingtype.
// If the Bookingtype object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BookingtypeMutation) OldBOOKTYPENAME(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBOOKTYPENAME is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBOOKTYPENAME requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBOOKTYPENAME: %w", err)
	}
	return oldValue.BOOKTYPENAME, nil
}

// ResetBOOKTYPENAME reset all changes of the "BOOKTYPE_NAME" field.
func (m *BookingtypeMutation) ResetBOOKTYPENAME() {
	m._BOOKTYPE_NAME = nil
}

// AddBooktypeIDs adds the booktype edge to Booking by ids.
func (m *BookingtypeMutation) AddBooktypeIDs(ids ...int) {
	if m.booktype == nil {
		m.booktype = make(map[int]struct{})
	}
	for i := range ids {
		m.booktype[ids[i]] = struct{}{}
	}
}

// RemoveBooktypeIDs removes the booktype edge to Booking by ids.
func (m *BookingtypeMutation) RemoveBooktypeIDs(ids ...int) {
	if m.removedbooktype == nil {
		m.removedbooktype = make(map[int]struct{})
	}
	for i := range ids {
		m.removedbooktype[ids[i]] = struct{}{}
	}
}

// RemovedBooktype returns the removed ids of booktype.
func (m *BookingtypeMutation) RemovedBooktypeIDs() (ids []int) {
	for id := range m.removedbooktype {
		ids = append(ids, id)
	}
	return
}

// BooktypeIDs returns the booktype ids in the mutation.
func (m *BookingtypeMutation) BooktypeIDs() (ids []int) {
	for id := range m.booktype {
		ids = append(ids, id)
	}
	return
}

// ResetBooktype reset all changes of the "booktype" edge.
func (m *BookingtypeMutation) ResetBooktype() {
	m.booktype = nil
	m.removedbooktype = nil
}

// Op returns the operation name.
func (m *BookingtypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Bookingtype).
func (m *BookingtypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *BookingtypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._BOOKTYPE_NAME != nil {
		fields = append(fields, bookingtype.FieldBOOKTYPENAME)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *BookingtypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bookingtype.FieldBOOKTYPENAME:
		return m.BOOKTYPENAME()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *BookingtypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bookingtype.FieldBOOKTYPENAME:
		return m.OldBOOKTYPENAME(ctx)
	}
	return nil, fmt.Errorf("unknown Bookingtype field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BookingtypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bookingtype.FieldBOOKTYPENAME:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBOOKTYPENAME(v)
		return nil
	}
	return fmt.Errorf("unknown Bookingtype field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *BookingtypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *BookingtypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BookingtypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Bookingtype numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *BookingtypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *BookingtypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *BookingtypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Bookingtype nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *BookingtypeMutation) ResetField(name string) error {
	switch name {
	case bookingtype.FieldBOOKTYPENAME:
		m.ResetBOOKTYPENAME()
		return nil
	}
	return fmt.Errorf("unknown Bookingtype field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *BookingtypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.booktype != nil {
		edges = append(edges, bookingtype.EdgeBooktype)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *BookingtypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bookingtype.EdgeBooktype:
		ids := make([]ent.Value, 0, len(m.booktype))
		for id := range m.booktype {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *BookingtypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedbooktype != nil {
		edges = append(edges, bookingtype.EdgeBooktype)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *BookingtypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case bookingtype.EdgeBooktype:
		ids := make([]ent.Value, 0, len(m.removedbooktype))
		for id := range m.removedbooktype {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *BookingtypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *BookingtypeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *BookingtypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Bookingtype unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *BookingtypeMutation) ResetEdge(name string) error {
	switch name {
	case bookingtype.EdgeBooktype:
		m.ResetBooktype()
		return nil
	}
	return fmt.Errorf("unknown Bookingtype edge %s", name)
}

// ClientEntityMutation represents an operation that mutate the ClientEntities
// nodes in the graph.
type ClientEntityMutation struct {
	config
	op             Op
	typ            string
	id             *int
	_CLIENT_NAME   *string
	_CLIENT_STATUS *string
	clearedFields  map[string]struct{}
	booked         map[int]struct{}
	removedbooked  map[int]struct{}
	done           bool
	oldValue       func(context.Context) (*ClientEntity, error)
}

var _ ent.Mutation = (*ClientEntityMutation)(nil)

// cliententityOption allows to manage the mutation configuration using functional options.
type cliententityOption func(*ClientEntityMutation)

// newClientEntityMutation creates new mutation for $n.Name.
func newClientEntityMutation(c config, op Op, opts ...cliententityOption) *ClientEntityMutation {
	m := &ClientEntityMutation{
		config:        c,
		op:            op,
		typ:           TypeClientEntity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClientEntityID sets the id field of the mutation.
func withClientEntityID(id int) cliententityOption {
	return func(m *ClientEntityMutation) {
		var (
			err   error
			once  sync.Once
			value *ClientEntity
		)
		m.oldValue = func(ctx context.Context) (*ClientEntity, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ClientEntity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClientEntity sets the old ClientEntity of the mutation.
func withClientEntity(node *ClientEntity) cliententityOption {
	return func(m *ClientEntityMutation) {
		m.oldValue = func(context.Context) (*ClientEntity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClientEntityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClientEntityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ClientEntityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCLIENTNAME sets the CLIENT_NAME field.
func (m *ClientEntityMutation) SetCLIENTNAME(s string) {
	m._CLIENT_NAME = &s
}

// CLIENTNAME returns the CLIENT_NAME value in the mutation.
func (m *ClientEntityMutation) CLIENTNAME() (r string, exists bool) {
	v := m._CLIENT_NAME
	if v == nil {
		return
	}
	return *v, true
}

// OldCLIENTNAME returns the old CLIENT_NAME value of the ClientEntity.
// If the ClientEntity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ClientEntityMutation) OldCLIENTNAME(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCLIENTNAME is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCLIENTNAME requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCLIENTNAME: %w", err)
	}
	return oldValue.CLIENTNAME, nil
}

// ResetCLIENTNAME reset all changes of the "CLIENT_NAME" field.
func (m *ClientEntityMutation) ResetCLIENTNAME() {
	m._CLIENT_NAME = nil
}

// SetCLIENTSTATUS sets the CLIENT_STATUS field.
func (m *ClientEntityMutation) SetCLIENTSTATUS(s string) {
	m._CLIENT_STATUS = &s
}

// CLIENTSTATUS returns the CLIENT_STATUS value in the mutation.
func (m *ClientEntityMutation) CLIENTSTATUS() (r string, exists bool) {
	v := m._CLIENT_STATUS
	if v == nil {
		return
	}
	return *v, true
}

// OldCLIENTSTATUS returns the old CLIENT_STATUS value of the ClientEntity.
// If the ClientEntity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ClientEntityMutation) OldCLIENTSTATUS(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCLIENTSTATUS is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCLIENTSTATUS requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCLIENTSTATUS: %w", err)
	}
	return oldValue.CLIENTSTATUS, nil
}

// ResetCLIENTSTATUS reset all changes of the "CLIENT_STATUS" field.
func (m *ClientEntityMutation) ResetCLIENTSTATUS() {
	m._CLIENT_STATUS = nil
}

// AddBookedIDs adds the booked edge to Booking by ids.
func (m *ClientEntityMutation) AddBookedIDs(ids ...int) {
	if m.booked == nil {
		m.booked = make(map[int]struct{})
	}
	for i := range ids {
		m.booked[ids[i]] = struct{}{}
	}
}

// RemoveBookedIDs removes the booked edge to Booking by ids.
func (m *ClientEntityMutation) RemoveBookedIDs(ids ...int) {
	if m.removedbooked == nil {
		m.removedbooked = make(map[int]struct{})
	}
	for i := range ids {
		m.removedbooked[ids[i]] = struct{}{}
	}
}

// RemovedBooked returns the removed ids of booked.
func (m *ClientEntityMutation) RemovedBookedIDs() (ids []int) {
	for id := range m.removedbooked {
		ids = append(ids, id)
	}
	return
}

// BookedIDs returns the booked ids in the mutation.
func (m *ClientEntityMutation) BookedIDs() (ids []int) {
	for id := range m.booked {
		ids = append(ids, id)
	}
	return
}

// ResetBooked reset all changes of the "booked" edge.
func (m *ClientEntityMutation) ResetBooked() {
	m.booked = nil
	m.removedbooked = nil
}

// Op returns the operation name.
func (m *ClientEntityMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ClientEntity).
func (m *ClientEntityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ClientEntityMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._CLIENT_NAME != nil {
		fields = append(fields, cliententity.FieldCLIENTNAME)
	}
	if m._CLIENT_STATUS != nil {
		fields = append(fields, cliententity.FieldCLIENTSTATUS)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ClientEntityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cliententity.FieldCLIENTNAME:
		return m.CLIENTNAME()
	case cliententity.FieldCLIENTSTATUS:
		return m.CLIENTSTATUS()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ClientEntityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cliententity.FieldCLIENTNAME:
		return m.OldCLIENTNAME(ctx)
	case cliententity.FieldCLIENTSTATUS:
		return m.OldCLIENTSTATUS(ctx)
	}
	return nil, fmt.Errorf("unknown ClientEntity field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ClientEntityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cliententity.FieldCLIENTNAME:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCLIENTNAME(v)
		return nil
	case cliententity.FieldCLIENTSTATUS:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCLIENTSTATUS(v)
		return nil
	}
	return fmt.Errorf("unknown ClientEntity field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ClientEntityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ClientEntityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ClientEntityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ClientEntity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ClientEntityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ClientEntityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClientEntityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ClientEntity nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ClientEntityMutation) ResetField(name string) error {
	switch name {
	case cliententity.FieldCLIENTNAME:
		m.ResetCLIENTNAME()
		return nil
	case cliententity.FieldCLIENTSTATUS:
		m.ResetCLIENTSTATUS()
		return nil
	}
	return fmt.Errorf("unknown ClientEntity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ClientEntityMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.booked != nil {
		edges = append(edges, cliententity.EdgeBooked)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ClientEntityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cliententity.EdgeBooked:
		ids := make([]ent.Value, 0, len(m.booked))
		for id := range m.booked {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ClientEntityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedbooked != nil {
		edges = append(edges, cliententity.EdgeBooked)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ClientEntityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case cliententity.EdgeBooked:
		ids := make([]ent.Value, 0, len(m.removedbooked))
		for id := range m.removedbooked {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ClientEntityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ClientEntityMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ClientEntityMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ClientEntity unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ClientEntityMutation) ResetEdge(name string) error {
	switch name {
	case cliententity.EdgeBooked:
		m.ResetBooked()
		return nil
	}
	return fmt.Errorf("unknown ClientEntity edge %s", name)
}

// RoleMutation represents an operation that mutate the Roles
// nodes in the graph.
type RoleMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_ROLE_NAME    *string
	clearedFields map[string]struct{}
	role          map[int]struct{}
	removedrole   map[int]struct{}
	done          bool
	oldValue      func(context.Context) (*Role, error)
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows to manage the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for $n.Name.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the id field of the mutation.
func withRoleID(id int) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *RoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetROLENAME sets the ROLE_NAME field.
func (m *RoleMutation) SetROLENAME(s string) {
	m._ROLE_NAME = &s
}

// ROLENAME returns the ROLE_NAME value in the mutation.
func (m *RoleMutation) ROLENAME() (r string, exists bool) {
	v := m._ROLE_NAME
	if v == nil {
		return
	}
	return *v, true
}

// OldROLENAME returns the old ROLE_NAME value of the Role.
// If the Role object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoleMutation) OldROLENAME(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldROLENAME is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldROLENAME requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldROLENAME: %w", err)
	}
	return oldValue.ROLENAME, nil
}

// ResetROLENAME reset all changes of the "ROLE_NAME" field.
func (m *RoleMutation) ResetROLENAME() {
	m._ROLE_NAME = nil
}

// AddRoleIDs adds the role edge to User by ids.
func (m *RoleMutation) AddRoleIDs(ids ...int) {
	if m.role == nil {
		m.role = make(map[int]struct{})
	}
	for i := range ids {
		m.role[ids[i]] = struct{}{}
	}
}

// RemoveRoleIDs removes the role edge to User by ids.
func (m *RoleMutation) RemoveRoleIDs(ids ...int) {
	if m.removedrole == nil {
		m.removedrole = make(map[int]struct{})
	}
	for i := range ids {
		m.removedrole[ids[i]] = struct{}{}
	}
}

// RemovedRole returns the removed ids of role.
func (m *RoleMutation) RemovedRoleIDs() (ids []int) {
	for id := range m.removedrole {
		ids = append(ids, id)
	}
	return
}

// RoleIDs returns the role ids in the mutation.
func (m *RoleMutation) RoleIDs() (ids []int) {
	for id := range m.role {
		ids = append(ids, id)
	}
	return
}

// ResetRole reset all changes of the "role" edge.
func (m *RoleMutation) ResetRole() {
	m.role = nil
	m.removedrole = nil
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._ROLE_NAME != nil {
		fields = append(fields, role.FieldROLENAME)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldROLENAME:
		return m.ROLENAME()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldROLENAME:
		return m.OldROLENAME(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldROLENAME:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetROLENAME(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *RoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *RoleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldROLENAME:
		m.ResetROLENAME()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.role != nil {
		edges = append(edges, role.EdgeRole)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeRole:
		ids := make([]ent.Value, 0, len(m.role))
		for id := range m.role {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedrole != nil {
		edges = append(edges, role.EdgeRole)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeRole:
		ids := make([]ent.Value, 0, len(m.removedrole))
		for id := range m.removedrole {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// UserMutation represents an operation that mutate the Users
// nodes in the graph.
type UserMutation struct {
	config
	op              Op
	typ             string
	id              *int
	_USER_EMAIL     *string
	_USER_NAME      *string
	clearedFields   map[string]struct{}
	booking         map[int]struct{}
	removedbooking  map[int]struct{}
	roleplay        *int
	clearedroleplay bool
	done            bool
	oldValue        func(context.Context) (*User, error)
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows to manage the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for $n.Name.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the id field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUSEREMAIL sets the USER_EMAIL field.
func (m *UserMutation) SetUSEREMAIL(s string) {
	m._USER_EMAIL = &s
}

// USEREMAIL returns the USER_EMAIL value in the mutation.
func (m *UserMutation) USEREMAIL() (r string, exists bool) {
	v := m._USER_EMAIL
	if v == nil {
		return
	}
	return *v, true
}

// OldUSEREMAIL returns the old USER_EMAIL value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldUSEREMAIL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUSEREMAIL is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUSEREMAIL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUSEREMAIL: %w", err)
	}
	return oldValue.USEREMAIL, nil
}

// ResetUSEREMAIL reset all changes of the "USER_EMAIL" field.
func (m *UserMutation) ResetUSEREMAIL() {
	m._USER_EMAIL = nil
}

// SetUSERNAME sets the USER_NAME field.
func (m *UserMutation) SetUSERNAME(s string) {
	m._USER_NAME = &s
}

// USERNAME returns the USER_NAME value in the mutation.
func (m *UserMutation) USERNAME() (r string, exists bool) {
	v := m._USER_NAME
	if v == nil {
		return
	}
	return *v, true
}

// OldUSERNAME returns the old USER_NAME value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldUSERNAME(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUSERNAME is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUSERNAME requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUSERNAME: %w", err)
	}
	return oldValue.USERNAME, nil
}

// ResetUSERNAME reset all changes of the "USER_NAME" field.
func (m *UserMutation) ResetUSERNAME() {
	m._USER_NAME = nil
}

// AddBookingIDs adds the booking edge to Booking by ids.
func (m *UserMutation) AddBookingIDs(ids ...int) {
	if m.booking == nil {
		m.booking = make(map[int]struct{})
	}
	for i := range ids {
		m.booking[ids[i]] = struct{}{}
	}
}

// RemoveBookingIDs removes the booking edge to Booking by ids.
func (m *UserMutation) RemoveBookingIDs(ids ...int) {
	if m.removedbooking == nil {
		m.removedbooking = make(map[int]struct{})
	}
	for i := range ids {
		m.removedbooking[ids[i]] = struct{}{}
	}
}

// RemovedBooking returns the removed ids of booking.
func (m *UserMutation) RemovedBookingIDs() (ids []int) {
	for id := range m.removedbooking {
		ids = append(ids, id)
	}
	return
}

// BookingIDs returns the booking ids in the mutation.
func (m *UserMutation) BookingIDs() (ids []int) {
	for id := range m.booking {
		ids = append(ids, id)
	}
	return
}

// ResetBooking reset all changes of the "booking" edge.
func (m *UserMutation) ResetBooking() {
	m.booking = nil
	m.removedbooking = nil
}

// SetRoleplayID sets the roleplay edge to Role by id.
func (m *UserMutation) SetRoleplayID(id int) {
	m.roleplay = &id
}

// ClearRoleplay clears the roleplay edge to Role.
func (m *UserMutation) ClearRoleplay() {
	m.clearedroleplay = true
}

// RoleplayCleared returns if the edge roleplay was cleared.
func (m *UserMutation) RoleplayCleared() bool {
	return m.clearedroleplay
}

// RoleplayID returns the roleplay id in the mutation.
func (m *UserMutation) RoleplayID() (id int, exists bool) {
	if m.roleplay != nil {
		return *m.roleplay, true
	}
	return
}

// RoleplayIDs returns the roleplay ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// RoleplayID instead. It exists only for internal usage by the builders.
func (m *UserMutation) RoleplayIDs() (ids []int) {
	if id := m.roleplay; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoleplay reset all changes of the "roleplay" edge.
func (m *UserMutation) ResetRoleplay() {
	m.roleplay = nil
	m.clearedroleplay = false
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._USER_EMAIL != nil {
		fields = append(fields, user.FieldUSEREMAIL)
	}
	if m._USER_NAME != nil {
		fields = append(fields, user.FieldUSERNAME)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUSEREMAIL:
		return m.USEREMAIL()
	case user.FieldUSERNAME:
		return m.USERNAME()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUSEREMAIL:
		return m.OldUSEREMAIL(ctx)
	case user.FieldUSERNAME:
		return m.OldUSERNAME(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUSEREMAIL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUSEREMAIL(v)
		return nil
	case user.FieldUSERNAME:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUSERNAME(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUSEREMAIL:
		m.ResetUSEREMAIL()
		return nil
	case user.FieldUSERNAME:
		m.ResetUSERNAME()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.booking != nil {
		edges = append(edges, user.EdgeBooking)
	}
	if m.roleplay != nil {
		edges = append(edges, user.EdgeRoleplay)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeBooking:
		ids := make([]ent.Value, 0, len(m.booking))
		for id := range m.booking {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRoleplay:
		if id := m.roleplay; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedbooking != nil {
		edges = append(edges, user.EdgeBooking)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeBooking:
		ids := make([]ent.Value, 0, len(m.removedbooking))
		for id := range m.removedbooking {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedroleplay {
		edges = append(edges, user.EdgeRoleplay)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeRoleplay:
		return m.clearedroleplay
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeRoleplay:
		m.ClearRoleplay()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeBooking:
		m.ResetBooking()
		return nil
	case user.EdgeRoleplay:
		m.ResetRoleplay()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
